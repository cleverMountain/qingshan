<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // 二叉搜索树
    // 通过链表封装
    class Node {
      constructor(key) {
        this.key = key
        this.left = null
        this.right = null
      }
    }
    class BinarySearchTree {
      constructor() {
        this.root = null
      }
      insert(key) {
        const node = new Node(key)
        // 没有根节点
        if (!this.root) {
          this.root = node
        } else {
          // 有根节点
          this.travelsalInsert(this.root, node)
        }
      }
      travelsalInsert(preNode, node) {
        // 左树
        if (preNode.key > node.key) {
          // 左树为空时node则直接赋值左树
          if (!preNode.left) {
            preNode.left = node
          } else {
            // 又把左树当做顶点继续比较
            this.travelsalInsert(preNode.left, node)
          }
        } else {
          // 右数
          if (!preNode.right) {
            preNode.right = node
          } else {
            this.travelsalInsert(preNode.right, node)
          }
        }
      }
      // 遍历(深度优先搜索)
      travelsal(handler) {
        this.travelsalVisit(this.root, handler)
      }
      travelsalVisit(node, handler) {
        if (!node) return false
        handler(node.key)
        if (node.left) {
          this.travelsalVisit(node.left, handler)
        }
        if (node.right) {
          this.travelsalVisit(node.right, handler)
        }
      }
      // 广度优先搜索
      bfs(handler) {
        // 思路也是一样的，定义一个队列，把最根放入队列，当访问的时候取出来，如果
        // 访问这个节点相连还有其它节点时继续放进队列，一直到队列的长度为0
        let queue = [this.root]
        while (queue.length) {
          let cur = queue.shift()
          if (cur.left) {
            queue.push(cur.left)
          }
          if (cur.right) {
            queue.push(cur.right)
          }
          handler(cur.key)
        }
      }
      // 获取小大值
      getMin() {
        let root = this.root
        let res
        while (root.left) {
          root = root.left
          res = root.key
        }
        return res
      }
      // 获取最大值
      getMax() {
        let root = this.root
        let res
        while (root.right) {
          root = root.right
          res = root.key
        }
        return res
      }
      // 判断是否存在
      has(key) {
        let root = this.root
        while (root) {
          if (root.key > key) {
            root = root.left
          } else if (root.key < key) {
            root = root.right
          } else {
            return true
          }
        }
        return false
      }

    }
    const tree = new BinarySearchTree()
    tree.insert(3)
    tree.insert(1)
    tree.insert(2)
    tree.insert(4)
    // tree.travelsal((node) => {
    //   console.log(node)
    // })
    // tree.bfs((key) => {
    //   console.log(key)
    // })

    console.log(tree)
    // console.log(tree.getMax())
    console.log(tree.has(5))
  </script>
</body>

</html>